const {
  decodeField,
} = require('./decodeAST');

const {
  generateFullQueryCode,
} = require('./fragment')

function generateTypeInfoFromQuery(ast, typeMap) {
  let types = {};
  extractType(types, ast, [], typeMap, "Query");

  let typeList = childTypes(types, types["Query"]);
  let typeInfo = {
    list: typeList,
    map: types,
    unconflictedNames: 
      typeList
      .map(type => type.selectionName)
      .reduce((prev, curr) => {
        return prev.includes(curr) 
          ? prev.filter(name => name != curr)
          : [...prev, curr]
      }, [])
  }
  return typeInfo;
}

function extractType(types, ast, selectionNames, typeMap, currentType) {
  let fields = ast.selectionSet.selections.map(selection => {
    let name = selection.name.value;
    let typeObj = typeMap[currentType].fields[selection.name.value];
    let typeName = typeObj.type;
    
    if(selection.selectionSet) {
      extractType(types, selection, [...selectionNames, name], typeMap, typeName);
    }

    return {
      ...typeObj,
      name,
      type: isScalar(typeName)
        ? typeName
        : [...selectionNames, name, typeName].join('_'),
    }
  })
  
  let name = [...selectionNames, currentType].join('_');
  types[name] = {
    name,
    selectionName: selectionNames.length > 0 
      ? selectionNames[selectionNames.length - 1]
      : currentType,
    fields,
  }
}

function childTypes(types, type) {
  let typeList = []
  type.fields.reverse().forEach(field => {
    if(!isScalar(field.type)){
      typeList = childTypes(types, types[field.type]).concat(typeList);
    }
  });
  type.fields.reverse();
  if(!type.inList) {
    typeList.push(type);
    type.inList = true;
  }
  return typeList;
}

function argumentTypes(args) {
  let fields = args.map(arg => {
    return decodeField(arg);
  })

  let list = [];
  if (fields.length > 0) {
    let types = [];
    types.push({
      name: 'variablesType',
      fields,
    });
    types.push({
      name: 'queryVars',
      fields,
      abstract: true,
    });

    list = types;
  }

  let map = {};

  list.forEach(type => {
    map[type.name] = type;
  })

  return {
    list, 
    map,
    unconflictedNames: 
      list.map(type => type.name)
  }
}

function generateReasonCode(node, typeInfo, argsTypeInfo) {
  return `
${commentOnTop()}

let query = {|
${generateFullQueryCode(node)}
|}

${generateTypeCode(typeInfo)}

${generateVariablesEncoder(argsTypeInfo)}

[@bs.module "./AppQuery.codec"]external decodeQueryResult: Js.Json.t => queryResult = "decodeQueryResult";
`.trim();
}

function commentOnTop() {
  return '/* Generated by ReasonQL Compiler, PLEASE EDIT WITH CARE */'
}

function generateTypeCode(typeInfo) {
  return typeInfo.list.map(type => {
    let name = getValidTypeName(typeInfo, type.name);
    
    return (type.abstract ? `[@bs.deriving abstract]\n` : ``)
+ `type ${lowerTheFirstCharacter(name)} = {
${
  type.fields.map(field => {
    return `  ${field.name}: ${wrapTypeName(typeInfo, field)},`
  }).join('\n')
}
};
`.trim();
  }).join('\n\n');
}

function wrapTypeName(typeInfo, field) {
  let typeName = getValidTypeName(typeInfo, field.type);

  typeName = field.contentOption
    ? `option(${typeName})`
    : typeName;
  
  typeName = field.array
    ? `array(${typeName})`
    : typeName;

  return field.option? `option(${typeName})` : typeName;
}

function generateVariablesEncoder(argsTypeInfo) {
  if(argsTypeInfo.list.length > 0) {
    let variableArgs = generateVariablesArgs(argsTypeInfo.map['variablesType'].fields);
    return `
${generateTypeCode(argsTypeInfo)}

let encodeVariables: variablesType => queryVars = (vars) => queryVars(${variableArgs});
`.trim();
  } else {
    return `
type variablesType = Js.Dict.t(Js.Json.t);
let encodeVariables: variablesType => Js.Json.t = vars => Js.Json.object_(vars);
`.trim();
  }
}

function generateVariablesArgs(fields) {
  return fields.map(field => `~${field.name}=vars.${field.name}`).join(',')
}

function getValidTypeName(typeInfo, typeName) {
  if(isScalar(typeName)) {
    let typeNames = {
      "ID": "string",
      "String": "string",
      "Boolean": "bool",
      "Int": "int",
      "Float": "float",
    };

    return typeNames[typeName];
  } else {
    let selectionName = typeInfo.map[typeName].selectionName;
    let name = 
      typeInfo.unconflictedNames.includes(selectionName)
      ? selectionName
      : typeName

    let rootNames = ["Query", "Mutation", "Subscription"];
    name = rootNames.includes(name) ? name + "Result" : name;

    return lowerTheFirstCharacter(name);
  }
}

function lowerTheFirstCharacter(name) {
  return name[0].toLowerCase() + name.substring(1);
}

function upperTheFirstCharacter(name) {
  return name[0].toUpperCase() + name.substring(1);
}

// Added comment for sections because template string literals break 
// the code indentation. And it makes code hard to read. 
function generateCodec(typeInfo) {
  let exportedNames = [];
  let arrayTypes = new Set();

  let validTypeName = name => {
    return upperTheFirstCharacter(getValidTypeName(typeInfo, name));
  }

  // Functions
  let functions = typeInfo.list.map(type => {
    let functionName = `decode${validTypeName(type.name)}`;
    exportedNames.push(functionName);
    
    return `
var ${functionName} = function (res) {
  return [
${type.fields.map(field => {
  let varname = `res.${field.name}`;

  if(isScalar(field.type)) {
    return `    ${varname},`;
  } else {
    let validType = validTypeName(field.type);
    let decoderName = field.array
      ? `decode${validType}Array`
      : `decode${validType}`;
    
    if (field.array) {
      arrayTypes.add(validType);
    }

    return field.option
      ? `    ${varname} ? ${decoderName}(${varname}) : undefined,`
      : `    ${decoderName}(${varname}),`;
  }
}).join('\n')}
  ]
}`.trim();
  }).join('\n\n');

  // Array Decoders
  let arrayDecoders = Array.from(arrayTypes).map(type => {
    exportedNames.push(`decode${type}Array`);
    return `
var decode${type}Array = function (arr) {
  return arr.map(item =>
    item ? decode${type}(item) : undefined
  )
}
`.trim()
  }
).join('\n\n')

  // exports part.
  let exported = exportedNames.map(name => 
    `exports.${name} = ${name};`
  ).join('\n').trim();

  return `
${commentOnTop()}

${functions}
${arrayDecoders ? `\n${arrayDecoders}\n` : ''}
${exported}
`.trim();
}

function isScalar(type) {
  let scalarTypes = ["ID", "String", "Int", "Float", "Boolean"];
  return scalarTypes.includes(type);
}

exports.queryToReason = function(node, typeMap) {
  let queryRoot = node.ast.definitions[0];
  let typeInfo = generateTypeInfoFromQuery(queryRoot, typeMap);
  let argsTypeInfo = argumentTypes(queryRoot.variableDefinitions);
  return {
    reason: generateReasonCode(node, typeInfo, argsTypeInfo),
    codec: generateCodec(typeInfo),
  }
}